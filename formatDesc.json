{
  _selector: "",
  _render: function(){},
  _assign: function(){},
  _register_render: function(){},
  _register_assign: function(){},
  
  a : "",
  b : ""
  
} ==>  {
  _meta_type : "_root",
  _meta_id : "", //optional

  _value: {
    _meta_type: "_value"
    _selector: "",
    _render: function(){},
    _assign: function(){},
    _register_render: function(){},
    _register_assign: function(){}
  },
  
  _prop: {
    _meta_type : "_prop"
    a : {
      _meta_type : "_root"
      ...
    },
    b : {
      _meta_type : "_root"
      ...
    },
  }
}  

{
  _duplicator: ""
  _item:{
    _selector : "",
    _index: "" 
    a: {},
    b: {}
  },
  length : ""
}  ==>  {
  _meta_type: "_root"
  _value:{ // the array itself
    _meta_type: "_value"
    _duplicator: ""
    _item : { // the element of the array
      _meta_type: "_root",
      // if stored, the index change can be watched, but this would be supported later, not now
      _store_index: false, 
      _value:{
        _meta_type: "_value"
        _selector : ""
      },
      _prop: {
        _meta_type: "_prop",
        // NOTE: the index can be rendered even not stored, maybe we need to clarify it more.
        _index: {},
        a: {},
        b: {}
      }
    },
  },
  _prop : {
    _meta_type : "_prop"
    length : ""
  }
} 

// for recursive fields, 
{
  propa:{
    _selector: ""
  },
  propb:{
    _value: {
      _selector: ""
    }
    subofb:{
      _selector:""
    }
  }
} ==> {
  _meta_type: "_root",
  _prop:{
    _meta_type: "_prop"
    propa:{
      _value :{
        _selector: ""
      }
    },
    propb:{
      _meta_type: "_root"
      _value: {
        _meta_type: "_value"
        _selector: ""
      },
      _prop:{
        subofb:{
          _meta_type: "_root"
          _value:{
            _selector:""
          }
        }
      }//_prop
    }// propb 
  }// _prop
}

//attr operations(1-way only),@> to suggest an operation of attribution

border: "#target-table@>[border=]",  //assign value to the target attribution
width: "#target-table@>[style:width=]", //assign value to the target style property
color: "#target-table@>[class:(blue|red)?]", // switch the class in declared list by given value(must contained in the list)
height: "#target-table@>[class:height40?]",  // add/remove target class by given value(treated as boolean)
checked: "#check-box@>[checked?]" // add/remove target attribution by given value(treated as boolean)


// form element rewrite
{
  name: {
    _form: "name"
  },
  sexOption: {
    _form_option: "sex"
  }
} ==> {
  name: {
    _form:{
      _name: "name",
      _default_change_event: "blur", //set to null to disable default change event
      _extra_change_events: ["keyup"] //optional, default is undefined 
    }
  },
  sexOption: {
    _form_option:{
      _name: "sex",
      _value: function(v){return v;},
      _text: function(v){return v;}
    }
  }
} == > {
  _selector: "[name=name]",
  _render: function(){},
  _assign: function(){},
  _register_render: function(){},
  _register_assign: function(){},
  
},{
  _selector: "[name=sex]",
  _render: function(){},
  _assign: function(){},
  _register_render: function(){},
  _register_assign: function(){},
  
}