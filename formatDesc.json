{
  _selector: "",
  _render: function(){},
  _assign: function(){},
  _register_render: function(){},
  _register_assign: function(){},
  
  a : "",
  b : ""
  
} ==>  {
  _meta_type : "_root",
  _meta_id : "", //optional

  _value: {
    _meta_type: "_value"
    _selector: "",
    _render: function(){},
    _assign: function(){},
    _register_render: function(){},
    _register_assign: function(){}
  },
  
  _prop: {
    _meta_type : "_prop"
    a : {
      _meta_type : "_root"
      ...
    },
    b : {
      _meta_type : "_root"
      ...
    },
  }
}  

{
  _duplicator: ""
  _item:{
    _selector : "",
    _index: "" 
    a: {},
    b: {}
  },
  length : ""
}  ==>  {
  _meta_type: "_root"
  _value:{ // the array itself
    _meta_type: "_value"
    _duplicator: ""
    _item : { // the element of the array
      _meta_type: "_root",
      // if stored, the index change can be watched, but this would be supported later, not now
      _store_index: false, 
      _value:{
        _meta_type: "_value"
        _selector : ""
      },
      _prop: {
        _meta_type: "_prop",
        // NOTE: the index can be rendered even not stored, maybe we need to clarify it more.
        _index: {},
        a: {},
        b: {}
      }
    },
  },
  _prop : {
    _meta_type : "_prop"
    length : ""
  }
} 

// for recursive fields, 
{
  propa:{
    _selector: ""
  },
  propb:{
    _value: {
      _selector: ""
    }
    subofb:{
      _selector:""
    }
  }
} ==> {
  _meta_type: "_root",
  _prop:{
    _meta_type: "_prop"
    propa:{
      _value :{
        _selector: ""
      }
    },
    propb:{
      _meta_type: "_root"
      _value: {
        _meta_type: "_value"
        _selector: ""
      },
      _prop:{
        subofb:{
          _meta_type: "_root"
          _value:{
            _selector:""
          }
        }
      }//_prop
    }// propb 
  }// _prop
}

//attr operations(1-way only),@> to suggest an operation of attribution

border: "#target-table@>[border=]",  //assign value to the target attribution
width: "#target-table@>[style:width=]", //assign value to the target style property
color: "#target-table@>[class:(blue|red)?]", // switch the class in declared list by given value(must contained in the list)
height: "#target-table@>[class:height40?]",  // add/remove target class by given value(treated as boolean)
checked: "#check-box@>[checked?]" // add/remove target attribution by given value(treated as boolean)


// form element rewrite
{
  name: {
    _form: {} // (not implemented yet)name can be ignored , the leaf property name will be treated as name of form element
  }
} ==>
{
  name: {
    _form: "name"
  }
} ==> {
  name: {
    _form:{
      _name: "name",
      _default_change_event: "blur", //set to null to disable default change event
      _extra_change_events: ["keyup"] //optional, default is undefined
      _option: undefined // for building option list
    }
  }
} == > {
  _selector: "[name=name]",
  _render: function(){},
  _assign: function(){},
  _register_render: function(){},
  _register_assign: function(){},
  
}


//form option bind
_option: Aj.optionBind($scope.dataOption,"bloodTypes")  ==>
{
  bloodTypes: {}
} ==> {
  bloodTypes: {
    _value: function(v){return v;},
    _text: function(v){return v}
  }
} ==> {
  bloodTypes: {
    _item: {
      _value: function(v){return v;},
      _text: function(v){return v}
    }
  }
} ==> { // in this step, it will be treated as normal array binding
  bloodTypes: {
    _duplicator: "",
    _item: {
      _selector: "",
      _render: function(){ (_value, _text) }, // _value, _text will be used as default rendering
      _assign: function(){}, //should do nothing
      _register_render: function(){},
      _register_assign: function(){}, //should do nothing
    }
  }
}

//select optgroup support(we will support it in furture)
_option: Aj.optionBind($scope.dataOption,{
  bloodTypes: {
    groupName: {
      _group_label: {}
    },
    list:{
      _sub_option: {},
    }
  }
}) ==> {
  bloodTypes: {
    groupName: {
      _group_label: {
        _label: function(v){return v;}
      }
    },
    list: {
      _sub_option:{
        _value: function(v){return v;},
        _text: function(v){return v}
      }
    }
  }
} ==> { // in this step, it will be treated as normal array binding
  bloodTypes: {
    _duplicator: "optgroup",
    _item: {
      groupName:{
        _selector: "optgroup@>[label=]",
        _render: function(){}, // default attr op render
        _assign: function(){}, //should do nothing
        _register_render: function(){}, //
        _register_assign: function(){}, //should do nothing,
      },
      list: {
        _duplicator: "option"
        _item: {
          _selector: "option",
          _render: function(){ (_value, _text) }, // _value, _text will be used as default rendering
          _assign: function(){}, //should do nothing
          _register_render: function(){},
          _register_assign: function(){}, //should do nothing,
        }
      }
    }
  }
}